Люди часто не понимают, что за ерунда происходит в SQLite с типами данных. Давайте разберемся.

SQLite использует пять типов данных:

INTEGER — целые числа,
REAL — действительные числа,
TEXT — строки,
BLOB — бинарные данные,
NULL — пустое значение.
А как вам такое:

SQLite может хранить данные любого типа — вне зависимости от того, какой тип указан на столбце.

Хотите записать число 3.14 в integer-поле? Пожалуйста (и никакого округления). Или, может быть, 'привет' в поле типа real? Без проблем.

Дело в том, что SQLite хранит тип не только на столбце, но и на каждом значении в таблице. Именно поэтому в одном столбце без проблем хранятся значения разных типов. Тип на столбце используется как рекомендация: при вставке SQLite пытается привести значение к рекомендуемому типу, но если не получилось — сохраняет «как есть».

Это удобно для анализа данных — можно сначала все загрузить, а потом средствами SQL разбираться с проблемными значениями. Любая другая СУБД выдаст ошибку при импорте и заставит вас «шерстить» файл скриптами или вручную.

С другой стороны, это неожиданное поведение, за которое многие недолюбливают SQLite и даже прозвали его «JavaScript в мире баз данных». Со временем разработчики SQLite прислушались и сделали альтернативный механизм «строгих» таблиц — но о нем в другой раз.

Тип значения
Функция typeof(value) возвращает тип значения:

with tmp as (
    select 42 as value
    union all
    select 3.14
    union all
    select 'всем sql'
    union all
    select x'1313'
    union all
    select null
)

select
  value,
  typeof(value) as type
from tmp;
┌──────────┬─────────┐
│  value   │  type   │
├──────────┼─────────┤
│ 42       │ integer │
│ 3.14     │ real    │
│ всем sql │ text    │
│          │ blob    │
│          │ null    │
└──────────┴─────────┘
Выражение cast(value as type) преобразует значение к указанному типу:

sqlite> .mode list
sqlite> .headers off

sqlite> select 'cast(42 as real) = ' || cast(42 as real);
cast(42 as real) = 42.0

sqlite> select 'cast(42 as text) = ' || cast(42 as text);
cast(42 as text) = 42

sqlite> select 'cast(3.14 as integer) = ' || cast(3.14 as integer);
cast(3.14 as integer) = 3

sqlite> select 'cast(3.14 as text) = ' || cast(3.14 as text);
cast(3.14 as text) = 3.14

sqlite> select 'cast(''всем sql'' as integer) = ' || cast('всем sql' as integer);
cast('всем sql' as integer) = 0

sqlite> select 'cast(''12. всем sql'' as integer) = ' || cast('12. всем sql' as integer);
cast('12. всем sql' as integer) = 12
NULL бесполезно приводить к другим типам — все равно останется NULL.

Числа
INTEGER и REAL — 64-битные числа. На практике это означает, что вряд ли вы встретите в данных число, которое не поместится в один из этих типов. Например, INTEGER поддерживает диапазон от -9223372036854775808 до 9223372036854775807. С REAL сложнее, но, думаю, идею вы уловили.

Вот несколько полезных функций для чисел:

min(X, Y, ...)

Возвращает минимальное из переданных значений.

sqlite> select min(42, 13);
13
with tmp as (
    select 42 as value
    union all
    select 13
    union all
    select 5
    union all
    select 7
)

select min(value)
from tmp
;
5
max(X, Y, ...)

Возвращает максимальное из переданных значений. Работает аналогично min().

random()

Возвращает случайное целое число во всем диапазоне INTEGER.

sqlite> select random();
6750223134178138503

sqlite> select random();
2536971354461690293

sqlite> select random();
7451408658391974798
round(X)
round(X, Y)

Округляет число X до Y знаков после десятичного разделителя. Если Y не указано, округляет X до ближайшего целого.

sqlite> select round(3.14159, 2);
3.14

sqlite> select round(3.14);
3.0

sqlite> select round(3.5);
4.0

sqlite> select round(3);
3.0
Кроме того, версии SQLite 3.35+ поддерживают стандартный набор математических функций: степени, логарифм, тригонометрию.

Строки
TEXT — строка произвольной длины. Удобно для анализа данных — никаких ошибок value too long при импорте, когда вы не знаете заранее предельную длину значений.

TEXT кодируется в UTF-8, так что без проблем работает с кириллицей, эмодзи и любыми другими символами.

Когда фильтруют набор данных, строки часто проверяют на частичное совпадение. Например, найти все слова (⬇скачать), которые начинаются на Ф:

.import --csv words.csv words
select word
from words
where word like 'ф%'
limit 3;
┌─────────┐
│  word   │
├─────────┤
│ фабрика │
│ факт    │
│ фамилия │
└─────────┘
Или все слова, у которых вторая буква — ю:

select word
from words
where word glob '[а-яё]ю*'
limit 3;
┌──────┐
│ word │
├──────┤
│ бюро │
│ июль │
│ июнь │
└──────┘
Поиск по строке с помощью GLOB

GLOB — не стандартный SQL-оператор. Это такой «LIKE на стероидах». Если LIKE поддерживает только _ (один символ) и % (что угодно), то GLOB умеет:

? — один символ (аналог _ у LIKE),
* — что угодно (аналог % у LIKE),
[...] — один символ из перечисленных в скобках,
[^...] — один символ, кроме перечисленных в скобках.
Например, [0-9][^abc]? расшифровывается как «любая цифра, затем любой символ кроме a, b, c, затем еще один символ».

Вот несколько полезных функций для строк:

length(X)

Возвращает количество символов в строке X.

sqlite> select length('SQL is awesome');
14
instr(X, Y)

Находит первое вхождение строки Y внутри строки X и возвращает порядковый номер символа, с которого оно начинается. Если Y не найдена внутри X, возвращает 0. Например:

sqlite> select instr('SQL is awesome', 'SQL');
1

sqlite> select instr('SQL is awesome', 'is');
5

sqlite> select instr('SQL is awesome', 'JS');
0
substr(X, Y, Z)
substr(X, Y)

Возвращает фрагмент строки X, который начинается с Y-го символа и имеет длину Z символов. Если Z не указано, возвращает фрагмент от Y-го символа до конца строки. Первый символ имеет номер 1. Например:

sqlite> select substr('SQL is awesome', 1, 3);
SQL

sqlite> select substr('SQL is awesome', 8);
awesome
replace(X, Y, Z)

Заменяет все фрагменты Y на фрагмент Z в строке X и возвращает получившуюся строку.

sqlite> select replace('JS is awesome', 'JS', 'SQL');
SQL is awesome

