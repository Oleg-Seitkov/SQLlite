До сих пор мы работали с одноуровневыми JSON-документами — массивами «плоских» объектов. Но бывает, что уровней несколько.

Например, вот двухуровневый справочник отраслей industry.sample.json 

[
    {
        "id": "7",
        "name": "Информационные технологии",
        "industries": [
            { "id": "7.538", "name": "Интернет-провайдер" },
            { "id": "7.539", "name": "ИТ-консалтинг" },
            { "id": "7.540", "name": "Разработка ПО" }
        ]
    },
    {
        "id": "9",
        "name": "Телекоммуникации, связь",
        "industries": [
            { "id": "9.399", "name": "Мобильная связь" },
            { "id": "9.400", "name": "Фиксированная связь" },
            { "id": "9.401", "name": "Оптоволоконная связь" }
        ]
    },
    {
        "id": "43",
        "name": "Финансовый сектор",
        "industries": [
            { "id": "43.641", "name": "Аудит" },
            { "id": "43.646", "name": "Страхование" },
            { "id": "43.647", "name": "Банк" }
        ]
    }
]
Допустим, мы хотим выбрать все отрасли второго уровня. Кажется, json_each() в этом не помощник:

select
  json_extract(value, '$.name') as name
from json_each(readfile('industry.sample.json'));
┌───────────────────────────┐
│           name            │
├───────────────────────────┤
│ Информационные технологии │
│ Телекоммуникации, связь   │
│ Финансовый сектор         │
└───────────────────────────┘
Он проходит только по верхнему уровню и не спускается на второй. Частично это можно исправить, передав необязательный второй параметр — «точку отсчета»:

select
  json_extract(value, '$.name') as name
from json_each(
  readfile('industry.sample.json'),
  '$[0].industries'
);
┌────────────────────┐
│        name        │
├────────────────────┤
│ Интернет-провайдер │
│ ИТ-консалтинг      │
│ Разработка ПО      │
└────────────────────┘
Мы указали, что следует обойти не массив верхнего уровня, а массив .industries у первого элемента верхнего массива ($[0]). Если бы нам были нужны только отрасли второго уровня из «информационных технологий» — было бы самое то. Но нам-то нужны все отрасли второго уровня!

json_tree()
Поможет функция json_tree(json). Она похожа на json_each(), только проходит по всем уровням json-документа, начиная с верхнего.

Тогда все просто, верно? Меняем json_each() на json_tree() — и вперед:

select
  json_extract(value, '$.name') as name
from json_tree(readfile('industry.sample.json'));
┌───────────────────────────┐
│           name            │
├───────────────────────────┤
│                           │
│ Информационные технологии │
│                           │
└───────────────────────────┘
Error: malformed JSON
Хм. json_extract() не смог извлечь атрибут name и сломался. Странно — ведь name есть у объектов обеих уровней:

industry.json

Проверим, какие значения возвращает json_tree():

select
  id,
  fullkey,
  type,
  substr(value, 1, 30) as value
from
  json_tree(readfile('industry.sample.json'))
limit 10;
┌────┬─────────────────────────┬────────┬────────────────────────────────┐
│ id │         fullkey         │  type  │             value              │
├────┼─────────────────────────┼────────┼────────────────────────────────┤
│ 0  │ $                       │ array  │ [{"id":"7","name":"Информацион │
│ 1  │ $[0]                    │ object │ {"id":"7","name":"Информационн │
│ 3  │ $[0].id                 │ text   │ 7                              │
│ 5  │ $[0].name               │ text   │ Информационные технологии      │
│ 7  │ $[0].industries         │ array  │ [{"id":"7.538","name":"Интерне │
│ 8  │ $[0].industries[0]      │ object │ {"id":"7.538","name":"Интернет │
│ 10 │ $[0].industries[0].id   │ text   │ 7.538                          │
│ 12 │ $[0].industries[0].name │ text   │ Интернет-провайдер             │
│ 13 │ $[0].industries[1]      │ object │ {"id":"7.539","name":"ИТ-конса │
│ 15 │ $[0].industries[1].id   │ text   │ 7.539                          │
└────┴─────────────────────────┴────────┴────────────────────────────────┘
id — это уникальный идентификатор, который json_tree() назначает каждой записи. Большого смысла в нем нет, потому что в зависимости от запроса могут генериться разные id для одних и тех же строчек. Здесь я вывел его только для того, чтобы удобнее было ссылаться на конкретные записи.

fullkey — это селектор элемента для конкретной записи. Он указывает, откуда взялось значение value.

type — это тип значения value (массив, объект или обычное значение).

Оказывается, json_tree() обошел вообще все элементы JSON-документа — не только массивы, но и конкретные объекты. Судите сами:

id	fullkey	value
0	$	Это вообще весь JSON-документ целиком
1	$[0]	Объект отрасли «информационные технологии»,
включая все ее отрасли второго уровня
3	$[0].id	Атрибут id отрасли «информационные технологии»
5	$[0].name	Атрибут name отрасли «информационные технологии»
7	$[0].industries	Атрибут industries отрасли «информационные технологии»,
то есть все ее отрасли второго уровня
8	$[0].industries[0]	Объект отрасли «информационные технологии > интернет-провайдер»
10	$[0].industries[0].id	Атрибут id отрасли «информационные технологии > интернет-провайдер»
12	$[0].industries[0].name	Атрибут name отрасли «информационные технологии > интернет-провайдер»
13	$[0].industries[1]	Объект отрасли «информационные технологии > ИТ консалтинг»
15	$[0].industries[1].id	Атрибут id отрасли «информационные технологии > ИТ консалтинг»
Давайте перформулируем задачу в терминах селекторов. Нам нужны все названия отраслей второго уровня:

$[0].industries[0].name
$[0].industries[1].name
$[0].industries[2].name
$[1].industries[0].name
$[1].industries[1].name
$[1].industries[2].name
...
Если обобщить, интересующий нас селектор выглядит так:

$[%].industries[%].name
Попробуем выбрать по нему:

select
  value
from
  json_tree(readfile('industry.sample.json'))
where
  fullkey like '$[%].industries[%].name'
;
┌──────────────────────┐
│        value         │
├──────────────────────┤
│ Интернет-провайдер   │
│ ИТ-консалтинг        │
│ Разработка ПО        │
│ Мобильная связь      │
│ Фиксированная связь  │
│ Оптоволоконная связь │
│ Аудит                │
│ Страхование          │
│ Банк                 │
└──────────────────────┘
Идеально!